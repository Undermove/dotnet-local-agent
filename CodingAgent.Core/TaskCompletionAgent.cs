using System.Text.Json;
using System.Text.Json.Serialization;
using OpenAI.Chat;

namespace CodingAgent.Core;

/// <summary>
/// –ê–≥–µ–Ω—Ç –¥–ª—è –¥–æ–≤–µ–¥–µ–Ω–∏—è —Å–ª–æ–∂–Ω—ã—Ö –∑–∞–¥–∞—á –¥–æ –∫–æ–Ω—Ü–∞ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º —Ü–∏–∫–ª–∞ TOTE (Test-Operate-Test-Exit)
/// </summary>
public class TaskCompletionAgent(
    IAIProvider provider,
    List<ToolDefinition> tools,
    bool verbose = false,
    TaskCompletionConfig? config = null)
{
    private readonly TaskCompletionConfig _config = config ?? new TaskCompletionConfig();

    /// <summary>
    /// –í—ã–ø–æ–ª–Ω—è–µ—Ç –∑–∞–¥–∞—á—É –¥–æ –ø–æ–ª–Ω–æ–≥–æ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è
    /// </summary>
    public async Task<TaskCompletionResult> CompleteTaskAsync(string taskDescription, List<string>? constraints = null)
    {
        var result = new TaskCompletionResult
        {
            TaskDescription = taskDescription,
            StartTime = DateTime.UtcNow,
            Constraints = constraints ?? new List<string>()
        };

        if (verbose)
        {
            Console.WriteLine($"üéØ Starting task completion: {taskDescription}");
            Console.WriteLine($"üìã Constraints: {string.Join(", ", result.Constraints)}");
        }

        try
        {
            // PLAN: –°–æ–∑–¥–∞–µ–º –ø–ª–∞–Ω –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –∑–∞–¥–∞—á–∏
            var plan = await CreateTaskPlanAsync(taskDescription, result.Constraints);
            result.Plan = plan;
                
            if (verbose)
            {
                Console.WriteLine($"üìù Created plan with {plan.Subtasks.Count} subtasks");
                foreach (var subtask in plan.Subtasks)
                {
                    Console.WriteLine($"  - {subtask.Id}: {subtask.Description} (Status: {subtask.Status})");
                }
            }

            // –û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª TOTE
            var iteration = 0;
            var isComplete = IsTaskComplete(plan);
            if (verbose)
            {
                Console.WriteLine($"üîç Task complete check: {isComplete}");
            }
                
            while (!isComplete && iteration < _config.MaxIterations)
            {
                iteration++;
                var iterationResult = new IterationResult { IterationNumber = iteration };
                    
                if (verbose)
                {
                    Console.WriteLine($"\nüîÑ Iteration {iteration}/{_config.MaxIterations}");
                }

                try
                {
                    // TEST: –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
                    var currentState = await AssessCurrentStateAsync(plan);
                    iterationResult.CurrentState = currentState;
                        
                    // –í—ã–±–∏—Ä–∞–µ–º —Å–ª–µ–¥—É—é—â—É—é –ø–æ–¥–∑–∞–¥–∞—á—É
                    var nextSubtask = SelectNextSubtask(plan);
                    if (nextSubtask == null)
                    {
                        if (verbose)
                        {
                            Console.WriteLine("‚úÖ No more subtasks to execute");
                        }
                        break;
                    }
                        
                    iterationResult.SelectedSubtask = nextSubtask;
                        
                    if (verbose)
                    {
                        Console.WriteLine($"üéØ Selected subtask: {nextSubtask.Description}");
                    }

                    // OPERATE: –í—ã–ø–æ–ª–Ω—è–µ–º –¥–µ–π—Å—Ç–≤–∏–µ
                    var actionResult = await ExecuteSubtaskAsync(nextSubtask);
                    iterationResult.ActionResult = actionResult;
                        
                    // OBSERVE: –ó–∞–ø—É—Å–∫–∞–µ–º –ø—Ä–æ–≤–µ—Ä–∫–∏
                    var observationResult = await ObserveResultsAsync(actionResult);
                    iterationResult.ObservationResult = observationResult;
                        
                    // CRITIQUE: –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
                    var critique = await CritiqueResultsAsync(observationResult, nextSubtask);
                    iterationResult.Critique = critique;
                        
                    // REFLECT/UPDATE: –û–±–Ω–æ–≤–ª—è–µ–º –ø–ª–∞–Ω
                    await UpdatePlanAsync(plan, critique, nextSubtask);
                        
                    iterationResult.Success = critique.IsSuccessful;
                        
                    if (verbose)
                    {
                        Console.WriteLine($"üìä Iteration {iteration} result: {(iterationResult.Success ? "‚úÖ Success" : "‚ùå Failed")}");
                        if (!string.IsNullOrEmpty(critique.Feedback))
                        {
                            Console.WriteLine($"üí¨ Feedback: {critique.Feedback}");
                        }
                    }
                }
                catch (Exception ex)
                {
                    iterationResult.Error = ex.Message;
                    iterationResult.Success = false;
                        
                    if (verbose)
                    {
                        Console.WriteLine($"‚ùå Iteration {iteration} failed: {ex.Message}");
                    }
                        
                    // –ü—ã—Ç–∞–µ–º—Å—è –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å—Å—è
                    await HandleIterationErrorAsync(plan, ex);
                }
                    
                result.Iterations.Add(iterationResult);
                    
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º —É—Å–ª–æ–≤–∏—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∏
                if (ShouldStopExecution(result, iteration))
                {
                    break;
                }
                    
                // –û–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–æ–≤–µ—Ä–∫—É –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –∑–∞–¥–∞—á–∏
                isComplete = IsTaskComplete(plan);
            }

            result.Success = IsTaskComplete(plan);
            result.EndTime = DateTime.UtcNow;
            result.TotalIterations = iteration;
                
            if (verbose)
            {
                Console.WriteLine($"\nüèÅ Task completion finished: {(result.Success ? "‚úÖ Success" : "‚ùå Failed")}");
                Console.WriteLine($"‚è±Ô∏è Duration: {result.Duration.TotalSeconds:F1}s, Iterations: {result.TotalIterations}");
            }
                
            return result;
        }
        catch (Exception ex)
        {
            result.Success = false;
            result.Error = ex.Message;
            result.EndTime = DateTime.UtcNow;
                
            if (verbose)
            {
                Console.WriteLine($"üí• Task completion failed: {ex.Message}");
            }
                
            return result;
        }
    }

    private async Task<TaskPlan> CreateTaskPlanAsync(string taskDescription, List<string> constraints)
    {
        var planningPrompt = $@"You are a task planning expert for a C# coding agent project. Create a detailed plan to complete the following task:

TASK: {taskDescription}

CONSTRAINTS: {string.Join(", ", constraints)}

AVAILABLE TOOLS: {string.Join(", ", tools.Select(t => t.Name))}

CONTEXT: This is a C# .NET project. When planning tasks:
- Use list_files and read_file to explore the codebase and understand existing implementations
- Implementation tasks should use edit_file to modify code
- Use bash tool for creating example files or running commands
- Build and test tools help validate changes

PLANNING METHODOLOGY:
For tasks involving extending or adding support for new formats/features:
1. ANALYZE EXISTING: First understand how similar functionality is currently implemented
2. RESEARCH NEW: Then research the new format/feature requirements
3. DESIGN: Plan the integration approach
4. IMPLEMENT: Make the necessary code changes
5. VALIDATE: Test the implementation

Create a plan with the following structure:
1. Break down the task into specific, actionable subtasks
2. For each subtask, define clear Definition of Done (DoD) criteria
3. Identify dependencies between subtasks
4. Prioritize subtasks (most blocking/enabling first)

IMPORTANT: When adding support for new file formats (like .slnx), start by finding and analyzing existing code that handles similar formats (like .sln) to understand the current implementation patterns.

Respond with a JSON structure like this:
{{
  ""subtasks"": [
    {{
      ""id"": ""subtask_1"",
      ""description"": ""Clear description of what needs to be done"",
      ""definitionOfDone"": [""Specific criteria 1"", ""Specific criteria 2""],
      ""dependencies"": [""subtask_id_that_must_be_completed_first""],
      ""priority"": 1,
      ""estimatedComplexity"": ""low|medium|high"",
      ""requiredTools"": [""tool_name_1"", ""tool_name_2""]
    }}
  ]
}}";

        var conversation = new List<ChatMessage>
        {
            new SystemChatMessage("You are a helpful task planning assistant. Always respond with valid JSON."),
            new UserChatMessage(planningPrompt)
        };

        var response = await provider.SendMessageWithToolsAsync(conversation, null, verbose);
            
        if (string.IsNullOrEmpty(response.TextContent))
        {
            throw new InvalidOperationException("Failed to generate task plan");
        }

        if (verbose)
        {
            Console.WriteLine($"üîç Raw AI response: {response.TextContent}");
        }

        try
        {
            // –û—á–∏—â–∞–µ–º JSON –æ—Ç markdown –±–ª–æ–∫–æ–≤ –∫–æ–¥–∞
            var cleanJson = ExtractJsonFromMarkdown(response.TextContent);
                
            if (verbose)
            {
                Console.WriteLine($"üîç Cleaned JSON: {cleanJson}");
            }
                
            var planData = JsonSerializer.Deserialize<TaskPlanData>(cleanJson);
                
            if (planData == null)
            {
                throw new InvalidOperationException("Failed to deserialize task plan: planData is null");
            }
                
            if (verbose)
            {
                Console.WriteLine($"üîç Deserialized plan data with {planData.Subtasks.Count} subtasks");
            }
                
            var plan = new TaskPlan
            {
                TaskDescription = taskDescription,
                Constraints = constraints,
                Subtasks = planData.Subtasks.Select(s => new Subtask
                {
                    Id = s.Id,
                    Description = s.Description,
                    DefinitionOfDone = s.DefinitionOfDone,
                    Dependencies = s.Dependencies,
                    Priority = s.Priority,
                    EstimatedComplexity = Enum.Parse<ComplexityLevel>(s.EstimatedComplexity, true),
                    RequiredTools = s.RequiredTools,
                    Status = SubtaskStatus.Pending
                }).ToList()
            };
                
            return plan;
        }
        catch (JsonException ex)
        {
            throw new InvalidOperationException($"Failed to parse task plan JSON: {ex.Message}. Response: {response.TextContent}");
        }
    }

    private async Task<string> AssessCurrentStateAsync(TaskPlan plan)
    {
        var completedTasks = plan.Subtasks.Where(s => s.Status == SubtaskStatus.Completed).Count();
        var totalTasks = plan.Subtasks.Count;
        var inProgressTasks = plan.Subtasks.Where(s => s.Status == SubtaskStatus.InProgress).Count();
        var failedTasks = plan.Subtasks.Where(s => s.Status == SubtaskStatus.Failed).Count();
        var replacedTasks = plan.Subtasks.Where(s => s.Status == SubtaskStatus.Replaced).Count();
        var skippedTasks = plan.Subtasks.Where(s => s.Status == SubtaskStatus.Skipped).Count();
        var adaptedTasks = plan.Subtasks.Where(s => s.IsAdapted).Count();
            
        var state = $"Progress: {completedTasks}/{totalTasks} completed, {inProgressTasks} in progress, {failedTasks} failed";
        if (replacedTasks > 0 || skippedTasks > 0 || adaptedTasks > 0)
        {
            state += $", {replacedTasks} replaced, {skippedTasks} skipped, {adaptedTasks} adapted";
        }
            
        return state;
    }

    private Subtask? SelectNextSubtask(TaskPlan plan)
    {
        // –í—ã–±–∏—Ä–∞–µ–º —Å–ª–µ–¥—É—é—â—É—é –ø–æ–¥–∑–∞–¥–∞—á—É –ø–æ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç—É, —É—á–∏—Ç—ã–≤–∞—è –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏
        var availableSubtasks = plan.Subtasks
            .Where(s => s.Status == SubtaskStatus.Pending)
            .Where(s => s.Dependencies.All(dep => 
                plan.Subtasks.Any(st => st.Id == dep && 
                                        (st.Status == SubtaskStatus.Completed || 
                                         st.Status == SubtaskStatus.Replaced || 
                                         st.Status == SubtaskStatus.Skipped))))
            .OrderBy(s => s.Priority)
            .ThenBy(s => s.EstimatedComplexity);
                
        return availableSubtasks.FirstOrDefault();
    }

    private async Task<ActionResult> ExecuteSubtaskAsync(Subtask subtask)
    {
        subtask.Status = SubtaskStatus.InProgress;
        subtask.StartTime = DateTime.UtcNow;
            
        var executionPrompt = $@"Execute the following subtask:

SUBTASK: {subtask.Description}
DEFINITION OF DONE: {string.Join(", ", subtask.DefinitionOfDone)}
REQUIRED TOOLS: {string.Join(", ", subtask.RequiredTools)}

Use the available tools to complete this subtask. Be specific and thorough.
Focus on meeting all the Definition of Done criteria.";

        var conversation = new List<ChatMessage>
        {
            new SystemChatMessage(GenerateExecutionSystemPrompt()),
            new UserChatMessage(executionPrompt)
        };

        var response = await provider.SendMessageWithToolsAsync(conversation, 
            ToolConverter.ConvertToOpenAITools(tools, verbose).Cast<object>().ToList(), verbose);

        if (verbose)
        {
            Console.WriteLine($"üîç ExecuteSubtaskAsync - Response received:");
            Console.WriteLine($"   TextContent: {response.TextContent}");
            Console.WriteLine($"   HasToolCalls: {response.HasToolCalls}");
            Console.WriteLine($"   ToolCalls.Count: {response.ToolCalls.Count}");
            if (response.ToolCalls.Count > 0)
            {
                foreach (var tc in response.ToolCalls)
                {
                    Console.WriteLine($"   - ToolCall: Name='{tc.Name}', Id='{tc.Id}', Args='{tc.Arguments}'");
                }
            }
            Console.WriteLine($"   Available tools in list: {string.Join(", ", tools.Select(t => $"'{t.Name}'"))}");
        }

        var actionResult = new ActionResult
        {
            SubtaskId = subtask.Id,
            Response = response.TextContent ?? "",
            ToolCallsExecuted = response.ToolCalls.Count,
            Success = !string.IsNullOrEmpty(response.TextContent) || response.HasToolCalls
        };

        // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º tool calls –µ—Å–ª–∏ –µ—Å—Ç—å
        if (response.HasToolCalls)
        {
            var toolResults = new List<string>();
            foreach (var toolCall in response.ToolCalls)
            {
                try
                {
                    if (verbose)
                    {
                        Console.WriteLine($"üîß Looking for tool: '{toolCall.Name}'");
                    }
                    
                    var tool = tools.FirstOrDefault(t => t.Name == toolCall.Name);
                    
                    if (tool != null)
                    {
                        if (verbose)
                        {
                            Console.WriteLine($"‚úÖ Found tool: '{toolCall.Name}', executing...");
                        }
                        var result = await tool.ExecuteAsync(toolCall.Arguments);
                        toolResults.Add($"{toolCall.Name}: {result}");
                    }
                    else
                    {
                        if (verbose)
                        {
                            Console.WriteLine($"‚ùå Tool NOT found: '{toolCall.Name}'. Available tools: {string.Join(", ", tools.Select(t => t.Name))}");
                        }
                        toolResults.Add($"{toolCall.Name}: Error - Tool not found");
                        actionResult.Success = false;
                    }
                }
                catch (Exception ex)
                {
                    toolResults.Add($"{toolCall.Name}: Error - {ex.Message}");
                    actionResult.Success = false;
                    if (verbose)
                    {
                        Console.WriteLine($"‚ùå Exception executing tool {toolCall.Name}: {ex.Message}");
                    }
                }
            }
            actionResult.ToolResults = toolResults;
        }

        subtask.EndTime = DateTime.UtcNow;
        return actionResult;
    }

    private async Task<ObservationResult> ObserveResultsAsync(ActionResult actionResult)
    {
        var observation = new ObservationResult
        {
            Metrics = new Dictionary<string, object>
            {
                ["tool_calls_executed"] = actionResult.ToolCallsExecuted,
                ["response_length"] = actionResult.Response?.Length ?? 0
            }
        };

        // –ü—ã—Ç–∞–µ–º—Å—è –Ω–∞–π—Ç–∏ .csproj –∏–ª–∏ .sln —Ñ–∞–π–ª—ã –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏
        var projectFiles = FindProjectFiles();
            
        if (projectFiles.Any())
        {
            var projectFile = projectFiles.First();
                
            if (verbose)
            {
                Console.WriteLine($"üîç Running validation checks on {projectFile}");
            }

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º build
            try
            {
                var buildTool = TaskValidationTools.BuildProjectDefinition;
                var buildInput = System.Text.Json.JsonSerializer.Serialize(new { project_path = projectFile });
                var buildResult = await buildTool.ExecuteAsync(buildInput);
                    
                var buildData = System.Text.Json.JsonSerializer.Deserialize<JsonElement>(buildResult);
                observation.BuildSuccess = buildData.GetProperty("Success").GetBoolean();
                    
                if (!observation.BuildSuccess)
                {
                    observation.Logs.Add($"Build failed: {buildData.GetProperty("Error").GetString()}");
                }
            }
            catch (Exception ex)
            {
                observation.BuildSuccess = false;
                observation.Logs.Add($"Build check failed: {ex.Message}");
            }

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–æ–¥–∞
            try
            {
                var lintTool = TaskValidationTools.LintCodeDefinition;
                var lintInput = System.Text.Json.JsonSerializer.Serialize(new { 
                    path = projectFile, 
                    verify_no_changes = true,
                    dry_run = true 
                });
                var lintResult = await lintTool.ExecuteAsync(lintInput);
                    
                var lintData = System.Text.Json.JsonSerializer.Deserialize<JsonElement>(lintResult);
                observation.LintPass = lintData.GetProperty("Success").GetBoolean();
                    
                if (!observation.LintPass)
                {
                    observation.Logs.Add($"Linting issues found: {lintData.GetProperty("Error").GetString()}");
                }
            }
            catch (Exception ex)
            {
                observation.LintPass = true; // –ù–µ –∫—Ä–∏—Ç–∏—á–Ω–æ, –µ—Å–ª–∏ lint –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω
                observation.Logs.Add($"Lint check skipped: {ex.Message}");
            }

            // –ü—ã—Ç–∞–µ–º—Å—è –∑–∞–ø—É—Å—Ç–∏—Ç—å —Ç–µ—Å—Ç—ã (–µ—Å–ª–∏ –µ—Å—Ç—å)
            try
            {
                var testTool = TaskValidationTools.RunTestsDefinition;
                var testInput = System.Text.Json.JsonSerializer.Serialize(new { 
                    project_path = projectFile,
                    no_restore = true 
                });
                var testResult = await testTool.ExecuteAsync(testInput);
                    
                var testData = System.Text.Json.JsonSerializer.Deserialize<JsonElement>(testResult);
                observation.TestsPass = testData.GetProperty("Success").GetBoolean();
                    
                if (!observation.TestsPass)
                {
                    observation.Logs.Add($"Tests failed: {testData.GetProperty("Error").GetString()}");
                }
            }
            catch (Exception ex)
            {
                observation.TestsPass = true; // –ù–µ –∫—Ä–∏—Ç–∏—á–Ω–æ, –µ—Å–ª–∏ —Ç–µ—Å—Ç–æ–≤ –Ω–µ—Ç
                observation.Logs.Add($"Test check skipped: {ex.Message}");
            }
        }
        else
        {
            // –ï—Å–ª–∏ –Ω–µ—Ç –ø—Ä–æ–µ–∫—Ç–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤, —Å—á–∏—Ç–∞–µ–º —á—Ç–æ –≤—Å–µ –û–ö
            observation.BuildSuccess = true;
            observation.TestsPass = true;
            observation.LintPass = true;
            observation.Logs.Add("No project files found, skipping validation checks");
        }

        return observation;
    }

    private List<string> FindProjectFiles()
    {
        var projectFiles = new List<string>();
            
        try
        {
            // –ò—â–µ–º .sln —Ñ–∞–π–ª—ã –≤ —Ç–µ–∫—É—â–µ–π –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏
            projectFiles.AddRange(Directory.GetFiles(".", "*.sln"));
                
            // –ò—â–µ–º .csproj —Ñ–∞–π–ª—ã –≤ —Ç–µ–∫—É—â–µ–π –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ –∏ –ø–æ–¥–¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è—Ö
            projectFiles.AddRange(Directory.GetFiles(".", "*.csproj", SearchOption.AllDirectories));
                
            // –§–∏–ª—å—Ç—Ä—É–µ–º —Ñ–∞–π–ª—ã –≤ bin/obj –ø–∞–ø–∫–∞—Ö
            projectFiles = projectFiles
                .Where(f => !f.Contains("/bin/") && !f.Contains("\\bin\\") && 
                            !f.Contains("/obj/") && !f.Contains("\\obj\\"))
                .ToList();
        }
        catch (Exception ex)
        {
            if (verbose)
            {
                Console.WriteLine($"Error finding project files: {ex.Message}");
            }
        }
            
        return projectFiles;
    }

    private async Task<CritiqueResult> CritiqueResultsAsync(ObservationResult observation, Subtask subtask)
    {
        var critique = new CritiqueResult();
            
        // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø –∑–∞–¥–∞—á–∏ –¥–ª—è –±–æ–ª–µ–µ –≥–∏–±–∫–æ–π –æ—Ü–µ–Ω–∫–∏
        var isResearchTask = subtask.Description.ToLower().Contains("understand") || 
                             subtask.Description.ToLower().Contains("read") ||
                             subtask.Description.ToLower().Contains("research");
            
        var isImplementationTask = subtask.RequiredTools.Contains("edit_file") ||
                                   subtask.Description.ToLower().Contains("update") ||
                                   subtask.Description.ToLower().Contains("modify");
            
        // –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–∏–ø–∞ –∑–∞–¥–∞—á–∏
        if (!observation.BuildSuccess)
        {
            critique.Issues.Add("Build failed");
            critique.ErrorType = ErrorType.Compilation;
        }
            
        if (!observation.TestsPass && isImplementationTask)
        {
            critique.Issues.Add("Tests failed");
            critique.ErrorType = ErrorType.Logic;
        }
            
        // –î–ª—è –∑–∞–¥–∞—á –∏—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏—è/–ø–æ–Ω–∏–º–∞–Ω–∏—è –ª–∏–Ω—Ç–∏–Ω–≥ –Ω–µ –∫—Ä–∏—Ç–∏—á–µ–Ω
        if (!observation.LintPass && isImplementationTask)
        {
            critique.Issues.Add("Linting failed");
            critique.ErrorType = ErrorType.Style;
        }
        else if (!observation.LintPass && !isImplementationTask)
        {
            // –î–ª—è –∏—Å—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏—Ö –∑–∞–¥–∞—á –ª–∏–Ω—Ç–∏–Ω–≥ - —ç—Ç–æ –ø—Ä–æ—Å—Ç–æ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ
            critique.Issues.Add("Linting warnings (non-critical for research tasks)");
        }

        // –î–ª—è –∏—Å—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏—Ö –∑–∞–¥–∞—á —É—Å–ø–µ—Ö –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç—Å—è –ø–æ-–¥—Ä—É–≥–æ–º—É
        if (isResearchTask)
        {
            // –ò—Å—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å—Å–∫–∞—è –∑–∞–¥–∞—á–∞ —É—Å–ø–µ—à–Ω–∞, –µ—Å–ª–∏ –Ω–µ—Ç –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö –æ—à–∏–±–æ–∫ —Å–±–æ—Ä–∫–∏
            critique.IsSuccessful = observation.BuildSuccess;
        }
        else
        {
            // –î–ª—è –∑–∞–¥–∞—á —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ —Ç—Ä–µ–±—É–µ–º –≤—Å–µ –ø—Ä–æ–≤–µ—Ä–∫–∏
            critique.IsSuccessful = observation.BuildSuccess && observation.TestsPass && observation.LintPass;
        }
            
        if (critique.IsSuccessful)
        {
            critique.Feedback = "Subtask completed successfully";
            subtask.Status = SubtaskStatus.Completed;
        }
        else
        {
            var criticalIssues = critique.Issues.Where(i => !i.Contains("non-critical")).ToList();
            if (criticalIssues.Any())
            {
                critique.Feedback = $"Critical issues found: {string.Join(", ", criticalIssues)}";
                subtask.Status = SubtaskStatus.Failed;
            }
            else
            {
                critique.Feedback = "Subtask completed with minor warnings";
                critique.IsSuccessful = true;
                subtask.Status = SubtaskStatus.Completed;
            }
        }

        return critique;
    }

    private async Task UpdatePlanAsync(TaskPlan plan, CritiqueResult critique, Subtask subtask)
    {
        if (!critique.IsSuccessful)
        {
            // –ï—Å–ª–∏ –ø–æ–¥–∑–∞–¥–∞—á–∞ –ø—Ä–æ–≤–∞–ª–∏–ª–∞—Å—å, –º–æ–∂–µ–º –ø–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π –ø–æ–¥—Ö–æ–¥
            subtask.AttemptCount++;
                
            if (subtask.AttemptCount < _config.MaxSubtaskAttempts)
            {
                subtask.Status = SubtaskStatus.Pending; // –ü–æ–ø—Ä–æ–±—É–µ–º –µ—â–µ —Ä–∞–∑
                    
                if (verbose)
                {
                    Console.WriteLine($"üîÑ Retrying subtask {subtask.Id} (attempt {subtask.AttemptCount + 1}/{_config.MaxSubtaskAttempts})");
                }
            }
            else
            {
                if (verbose)
                {
                    Console.WriteLine($"‚ùå Subtask {subtask.Id} failed after {subtask.AttemptCount} attempts");
                }
                    
                // –ï—Å–ª–∏ –ø–æ–¥–∑–∞–¥–∞—á–∞ –ø—Ä–æ–≤–∞–ª–∏–ª–∞—Å—å –æ–∫–æ–Ω—á–∞—Ç–µ–ª—å–Ω–æ, –ø–æ–ø—Ä–æ–±—É–µ–º –∞–¥–∞–ø—Ç–∏—Ä–æ–≤–∞—Ç—å –ø–ª–∞–Ω
                await AdaptPlanAsync(plan, subtask, critique);
            }
        }
    }

    /// <summary>
    /// –ê–¥–∞–ø—Ç–∏—Ä—É–µ—Ç –ø–ª–∞–Ω, –µ—Å–ª–∏ –ø–æ–¥–∑–∞–¥–∞—á–∞ –ø—Ä–æ–≤–∞–ª–∏–ª–∞—Å—å –æ–∫–æ–Ω—á–∞—Ç–µ–ª—å–Ω–æ
    /// </summary>
    private async Task AdaptPlanAsync(TaskPlan plan, Subtask failedSubtask, CritiqueResult critique)
    {
        if (verbose)
        {
            Console.WriteLine($"üîÑ Attempting to adapt plan due to failed subtask: {failedSubtask.Id}");
        }

        try
        {
            // –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –ø—Ä–∏—á–∏–Ω—É –ø—Ä–æ–≤–∞–ª–∞ –∏ —Å–æ–∑–¥–∞–µ–º –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–µ –ø–æ–¥–∑–∞–¥–∞—á–∏
            var adaptationPrompt = $@"A subtask has failed multiple times and needs plan adaptation.

FAILED SUBTASK: {failedSubtask.Description}
FAILURE REASON: {critique.Feedback}
ERROR TYPE: {critique.ErrorType}
ISSUES: {string.Join(", ", critique.Issues)}

CURRENT PLAN CONTEXT:
- Total subtasks: {plan.Subtasks.Count}
- Completed: {plan.Subtasks.Count(s => s.Status == SubtaskStatus.Completed)}
- Failed: {plan.Subtasks.Count(s => s.Status == SubtaskStatus.Failed)}
- Pending: {plan.Subtasks.Count(s => s.Status == SubtaskStatus.Pending)}

AVAILABLE TOOLS: {string.Join(", ", tools.Select(t => t.Name))}

Please analyze the failure and suggest alternative approaches. Consider:
1. Breaking down the failed subtask into smaller, more specific steps
2. Using different tools or approaches
3. Addressing the root cause of the failure
4. Ensuring the new subtasks are achievable with existing files/context

Respond with a JSON structure containing new subtasks to replace or supplement the failed one:
{{
  ""adaptationStrategy"": ""replace|supplement|skip"",
  ""reasoning"": ""Explanation of why this adaptation is needed"",
  ""newSubtasks"": [
    {{
      ""id"": ""adapted_subtask_1"",
      ""description"": ""Clear description of what needs to be done"",
      ""definitionOfDone"": [""Specific criteria 1"", ""Specific criteria 2""],
      ""dependencies"": [""subtask_id_that_must_be_completed_first""],
      ""priority"": 1,
      ""estimatedComplexity"": ""low|medium|high"",
      ""requiredTools"": [""tool_name_1"", ""tool_name_2""]
    }}
  ]
}}";

            var conversation = new List<ChatMessage>
            {
                new SystemChatMessage("You are a helpful task planning assistant specialized in plan adaptation. Always respond with valid JSON."),
                new UserChatMessage(adaptationPrompt)
            };

            var response = await provider.SendMessageWithToolsAsync(conversation, null, verbose);
                
            if (!string.IsNullOrEmpty(response.TextContent))
            {
                var cleanJson = ExtractJsonFromMarkdown(response.TextContent);
                var adaptationData = JsonSerializer.Deserialize<PlanAdaptationData>(cleanJson);
                    
                if (adaptationData != null && adaptationData.NewSubtasks.Any())
                {
                    await ApplyPlanAdaptationAsync(plan, failedSubtask, adaptationData);
                }
            }
        }
        catch (Exception ex)
        {
            if (verbose)
            {
                Console.WriteLine($"‚ö†Ô∏è Failed to adapt plan: {ex.Message}");
            }
        }
    }

    /// <summary>
    /// –ü—Ä–∏–º–µ–Ω—è–µ—Ç –∞–¥–∞–ø—Ç–∞—Ü–∏—é –ø–ª–∞–Ω–∞
    /// </summary>
    private async Task ApplyPlanAdaptationAsync(TaskPlan plan, Subtask failedSubtask, PlanAdaptationData adaptation)
    {
        if (verbose)
        {
            Console.WriteLine($"üîß Applying plan adaptation: {adaptation.AdaptationStrategy}");
            Console.WriteLine($"üí° Reasoning: {adaptation.Reasoning}");
        }

        switch (adaptation.AdaptationStrategy.ToLower())
        {
            case "replace":
                // –ó–∞–º–µ–Ω—è–µ–º –ø—Ä–æ–≤–∞–ª–∏–≤—à—É—é—Å—è –ø–æ–¥–∑–∞–¥–∞—á—É –Ω–æ–≤—ã–º–∏
                failedSubtask.Status = SubtaskStatus.Replaced;
                await AddNewSubtasksAsync(plan, adaptation.NewSubtasks, failedSubtask.Priority);
                break;
                    
            case "supplement":
                // –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–µ –ø–æ–¥–∑–∞–¥–∞—á–∏ –≤ –¥–æ–ø–æ–ª–Ω–µ–Ω–∏–µ –∫ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–º
                await AddNewSubtasksAsync(plan, adaptation.NewSubtasks, failedSubtask.Priority);
                break;
                    
            case "skip":
                // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –ø—Ä–æ–≤–∞–ª–∏–≤—à—É—é—Å—è –ø–æ–¥–∑–∞–¥–∞—á—É –∏ –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º
                failedSubtask.Status = SubtaskStatus.Skipped;
                if (verbose)
                {
                    Console.WriteLine($"‚è≠Ô∏è Skipping subtask {failedSubtask.Id} as recommended");
                }
                break;
        }
    }

    /// <summary>
    /// –î–æ–±–∞–≤–ª—è–µ—Ç –Ω–æ–≤—ã–µ –ø–æ–¥–∑–∞–¥–∞—á–∏ –≤ –ø–ª–∞–Ω
    /// </summary>
    private async Task AddNewSubtasksAsync(TaskPlan plan, List<SubtaskData> newSubtasksData, int basePriority)
    {
        var newSubtasks = newSubtasksData.Select(s => new Subtask
        {
            Id = s.Id,
            Description = s.Description,
            DefinitionOfDone = s.DefinitionOfDone,
            Dependencies = s.Dependencies,
            Priority = s.Priority > 0 ? s.Priority : basePriority,
            EstimatedComplexity = Enum.Parse<ComplexityLevel>(s.EstimatedComplexity, true),
            RequiredTools = s.RequiredTools,
            Status = SubtaskStatus.Pending,
            IsAdapted = true // –ü–æ–º–µ—á–∞–µ–º –∫–∞–∫ –∞–¥–∞–ø—Ç–∏—Ä–æ–≤–∞–Ω–Ω—É—é –ø–æ–¥–∑–∞–¥–∞—á—É
        }).ToList();

        plan.Subtasks.AddRange(newSubtasks);
            
        if (verbose)
        {
            Console.WriteLine($"‚ûï Added {newSubtasks.Count} new adapted subtasks:");
            foreach (var subtask in newSubtasks)
            {
                Console.WriteLine($"  - {subtask.Id}: {subtask.Description}");
            }
        }
    }

    private async Task HandleIterationErrorAsync(TaskPlan plan, Exception error)
    {
        if (verbose)
        {
            Console.WriteLine($"üîß Handling iteration error: {error.Message}");
        }
            
        // –ú–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –ª–æ–≥–∏–∫—É –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è –ø–æ—Å–ª–µ –æ—à–∏–±–æ–∫
        await Task.Delay(1000); // –ù–µ–±–æ–ª—å—à–∞—è –ø–∞—É–∑–∞ –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–µ–π –ø–æ–ø—ã—Ç–∫–æ–π
    }

    private bool IsTaskComplete(TaskPlan plan)
    {
        // –ó–∞–¥–∞—á–∞ —Å—á–∏—Ç–∞–µ—Ç—Å—è –∑–∞–≤–µ—Ä—à–µ–Ω–Ω–æ–π, –µ—Å–ª–∏ –≤—Å–µ –ø–æ–¥–∑–∞–¥–∞—á–∏ –ª–∏–±–æ –≤—ã–ø–æ–ª–Ω–µ–Ω—ã, –ª–∏–±–æ –∑–∞–º–µ–Ω–µ–Ω—ã, –ª–∏–±–æ –ø—Ä–æ–ø—É—â–µ–Ω—ã
        return plan.Subtasks.All(s => s.Status == SubtaskStatus.Completed || 
                                      s.Status == SubtaskStatus.Replaced || 
                                      s.Status == SubtaskStatus.Skipped);
    }

    /// <summary>
    /// –ò–∑–≤–ª–µ–∫–∞–µ—Ç JSON –∏–∑ markdown –±–ª–æ–∫–∞ –∫–æ–¥–∞
    /// </summary>
    private static string ExtractJsonFromMarkdown(string text)
    {
        if (string.IsNullOrEmpty(text))
            return text;

        // –ò—â–µ–º JSON –±–ª–æ–∫ –≤ markdown (```json ... ```)
        var jsonBlockStart = text.IndexOf("```json");
        if (jsonBlockStart >= 0)
        {
            var jsonStart = text.IndexOf('\n', jsonBlockStart) + 1;
            var jsonEnd = text.IndexOf("```", jsonStart);
            if (jsonEnd > jsonStart)
            {
                return text.Substring(jsonStart, jsonEnd - jsonStart).Trim();
            }
        }

        // –ò—â–µ–º –æ–±—ã—á–Ω—ã–π –±–ª–æ–∫ –∫–æ–¥–∞ (``` ... ```)
        var codeBlockStart = text.IndexOf("```");
        if (codeBlockStart >= 0)
        {
            var codeStart = text.IndexOf('\n', codeBlockStart) + 1;
            var codeEnd = text.IndexOf("```", codeStart);
            if (codeEnd > codeStart)
            {
                var potentialJson = text.Substring(codeStart, codeEnd - codeStart).Trim();
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —ç—Ç–æ –ø–æ—Ö–æ–∂–µ –Ω–∞ JSON
                if (potentialJson.StartsWith("{") && potentialJson.EndsWith("}"))
                {
                    return potentialJson;
                }
            }
        }

        // –ï—Å–ª–∏ –Ω–µ—Ç markdown –±–ª–æ–∫–æ–≤, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –∏—Å—Ö–æ–¥–Ω—ã–π —Ç–µ–∫—Å—Ç
        return text.Trim();
    }

    private bool ShouldStopExecution(TaskCompletionResult result, int iteration)
    {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–∞–∑–ª–∏—á–Ω—ã–µ —É—Å–ª–æ–≤–∏—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∏
        if (iteration >= _config.MaxIterations)
        {
            if (verbose)
            {
                Console.WriteLine($"‚è∞ Stopping: Maximum iterations ({_config.MaxIterations}) reached");
            }
            return true;
        }

        if (result.Duration.TotalMinutes > _config.MaxExecutionTimeMinutes)
        {
            if (verbose)
            {
                Console.WriteLine($"‚è∞ Stopping: Maximum execution time ({_config.MaxExecutionTimeMinutes} min) reached");
            }
            return true;
        }

        var failedSubtasks = result.Plan?.Subtasks.Count(s => s.Status == SubtaskStatus.Failed) ?? 0;
        if (failedSubtasks > _config.MaxFailedSubtasks)
        {
            if (verbose)
            {
                Console.WriteLine($"‚ùå Stopping: Too many failed subtasks ({failedSubtasks})");
            }
            return true;
        }

        return false;
    }

    private string GenerateExecutionSystemPrompt()
    {
        var toolDescriptions = tools.Select(tool => 
            $"- {tool.Name}: {tool.Description}").ToList();
        var toolList = string.Join(Environment.NewLine, toolDescriptions);

        return $"You are a task execution specialist. Your job is to complete specific subtasks using available tools.{Environment.NewLine}" +
               $"{Environment.NewLine}" +
               $"AVAILABLE TOOLS:{Environment.NewLine}" +
               $"{toolList}{Environment.NewLine}" +
               $"{Environment.NewLine}" +
               $"EXECUTION PRINCIPLES:{Environment.NewLine}" +
               $"1. Read and understand the subtask carefully before acting{Environment.NewLine}" +
               $"2. Choose the RIGHT TOOL FOR THE JOB based on what needs to be accomplished{Environment.NewLine}" +
               $"3. For research/understanding tasks, use appropriate tools to gather information{Environment.NewLine}" +
               $"4. For implementation tasks, use tools to modify code and files{Environment.NewLine}" +
               $"5. For system commands, use bash tool{Environment.NewLine}" +
               $"6. Be thorough and check your work{Environment.NewLine}" +
               $"7. Focus on meeting all Definition of Done criteria{Environment.NewLine}" +
               $"8. If something fails, try alternative approaches{Environment.NewLine}" +
               $"9. Provide clear feedback on what was accomplished{Environment.NewLine}" +
               $"{Environment.NewLine}" +
               $"TOOL SELECTION GUIDELINES:{Environment.NewLine}" +
               $"- list_files: Use ONLY when you need to discover what files exist or explore directory structure{Environment.NewLine}" +
               $"- read_file: Use when you need to examine the contents of a specific file{Environment.NewLine}" +
               $"- edit_file: Use when you need to create or modify code/text files{Environment.NewLine}" +
               $"- bash: Use for running shell commands, building, or testing{Environment.NewLine}" +
               $"- Other tools: Use as needed for validation or specific operations{Environment.NewLine}" +
               $"{Environment.NewLine}" +
               $"CRITICAL - AVOID UNNECESSARY TOOL CALLS:{Environment.NewLine}" +
               $"- Do not use list_files just to explore - use it only when you genuinely need to know what files exist{Environment.NewLine}" +
               $"- Do not repeatedly use the same tool - use it once to get information, then use other tools{Environment.NewLine}" +
               $"- Each tool call should have a specific purpose and move the task forward{Environment.NewLine}" +
               $"{Environment.NewLine}" +
               $"METHODICAL APPROACH FOR CODE IMPLEMENTATION:{Environment.NewLine}" +
               $"1. UNDERSTAND THE TASK: Read the definition of done carefully{Environment.NewLine}" +
               $"2. EXECUTE: Use the most appropriate tool for each step (edit_file, bash, read_file, etc.){Environment.NewLine}" +
               $"3. VALIDATE: Check that requirements are met{Environment.NewLine}" +
               $"4. USE TOOLS STRATEGICALLY: Not all tasks require exploration - some need direct action{Environment.NewLine}" +
               $"{Environment.NewLine}" +
               $"IMPORTANT NOTES:{Environment.NewLine}" +
               $"- Do not assume files exist - use read_file or bash to check, then use appropriate tool{Environment.NewLine}" +
               $"- If you know what file you need to edit, use edit_file directly{Environment.NewLine}" +
               $"- When creating new functionality, use edit_file to create/modify files as needed{Environment.NewLine}" +
               $"- Use bash for compilation, testing, or running commands{Environment.NewLine}" +
               $"- When adding features, look at existing similar code patterns to understand the approach{Environment.NewLine}" +
               $"- Vary your tool usage based on actual task requirements{Environment.NewLine}" +
               $"{Environment.NewLine}" +
               $"Always use tools actively to complete the task - do not just provide instructions or explanations.{Environment.NewLine}" +
               $"Pick the right tool for each specific action you need to take.";
    }
}

// –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –¥–ª—è –∞–≥–µ–Ω—Ç–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –∑–∞–¥–∞—á
public class TaskCompletionConfig
{
    public int MaxIterations { get; set; } = 50;
    public int MaxSubtaskAttempts { get; set; } = 3;
    public int MaxFailedSubtasks { get; set; } = 5;
    public double MaxExecutionTimeMinutes { get; set; } = 30;
}

// –ú–æ–¥–µ–ª–∏ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è –∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –∑–∞–¥–∞—á
public class TaskPlan
{
    public string TaskDescription { get; set; } = "";
    public List<string> Constraints { get; set; } = new();
    public List<Subtask> Subtasks { get; set; } = new();
}

public class Subtask
{
    public string Id { get; set; } = "";
    public string Description { get; set; } = "";
    public List<string> DefinitionOfDone { get; set; } = new();
    public List<string> Dependencies { get; set; } = new();
    public int Priority { get; set; }
    public ComplexityLevel EstimatedComplexity { get; set; }
    public List<string> RequiredTools { get; set; } = new();
    public SubtaskStatus Status { get; set; } = SubtaskStatus.Pending;
    public int AttemptCount { get; set; } = 0;
    public DateTime? StartTime { get; set; }
    public DateTime? EndTime { get; set; }
    public bool IsAdapted { get; set; } = false; // –ü–æ–º–µ—á–∞–µ—Ç –∞–¥–∞–ø—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –ø–æ–¥–∑–∞–¥–∞—á–∏
}

public enum SubtaskStatus
{
    Pending,
    InProgress,
    Completed,
    Failed,
    Replaced,  // –ü–æ–¥–∑–∞–¥–∞—á–∞ –∑–∞–º–µ–Ω–µ–Ω–∞ –∞–¥–∞–ø—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–º–∏ –ø–æ–¥–∑–∞–¥–∞—á–∞–º–∏
    Skipped    // –ü–æ–¥–∑–∞–¥–∞—á–∞ –ø—Ä–æ–ø—É—â–µ–Ω–∞ –ø–æ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –∞–¥–∞–ø—Ç–∞—Ü–∏–∏
}

public enum ComplexityLevel
{
    Low,
    Medium,
    High
}

public enum ErrorType
{
    None,
    Compilation,
    Logic,
    Style,
    Environment,
    Network
}

public class TaskCompletionResult
{
    public string TaskDescription { get; set; } = "";
    public List<string> Constraints { get; set; } = new();
    public TaskPlan? Plan { get; set; }
    public List<IterationResult> Iterations { get; set; } = new();
    public bool Success { get; set; }
    public string? Error { get; set; }
    public DateTime StartTime { get; set; }
    public DateTime EndTime { get; set; }
    public int TotalIterations { get; set; }
    public TimeSpan Duration => EndTime - StartTime;
}

public class IterationResult
{
    public int IterationNumber { get; set; }
    public string CurrentState { get; set; } = "";
    public Subtask? SelectedSubtask { get; set; }
    public ActionResult? ActionResult { get; set; }
    public ObservationResult? ObservationResult { get; set; }
    public CritiqueResult? Critique { get; set; }
    public bool Success { get; set; }
    public string? Error { get; set; }
}

public class ActionResult
{
    public string SubtaskId { get; set; } = "";
    public string Response { get; set; } = "";
    public int ToolCallsExecuted { get; set; }
    public List<string> ToolResults { get; set; } = new();
    public bool Success { get; set; }
}

public class ObservationResult
{
    public bool BuildSuccess { get; set; } = true;
    public bool TestsPass { get; set; } = true;
    public bool LintPass { get; set; } = true;
    public Dictionary<string, object> Metrics { get; set; } = new();
    public List<string> Logs { get; set; } = new();
}

public class CritiqueResult
{
    public bool IsSuccessful { get; set; }
    public List<string> Issues { get; set; } = new();
    public ErrorType ErrorType { get; set; } = ErrorType.None;
    public string Feedback { get; set; } = "";
    public string? RecommendedAction { get; set; }
}

// –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ –∫–ª–∞—Å—Å—ã –¥–ª—è –¥–µ—Å–µ—Ä–∏–∞–ª–∏–∑–∞—Ü–∏–∏ JSON
internal class TaskPlanData
{
    [JsonPropertyName("subtasks")]
    public List<SubtaskData> Subtasks { get; set; } = new();
}

internal class SubtaskData
{
    [JsonPropertyName("id")]
    public string Id { get; set; } = "";
        
    [JsonPropertyName("description")]
    public string Description { get; set; } = "";
        
    [JsonPropertyName("definitionOfDone")]
    public List<string> DefinitionOfDone { get; set; } = new();
        
    [JsonPropertyName("dependencies")]
    public List<string> Dependencies { get; set; } = new();
        
    [JsonPropertyName("priority")]
    public int Priority { get; set; }
        
    [JsonPropertyName("estimatedComplexity")]
    public string EstimatedComplexity { get; set; } = "medium";
        
    [JsonPropertyName("requiredTools")]
    public List<string> RequiredTools { get; set; } = new();
}

/// <summary>
/// –ö–ª–∞—Å—Å –¥–ª—è –¥–µ—Å–µ—Ä–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –¥–∞–Ω–Ω—ã—Ö –∞–¥–∞–ø—Ç–∞—Ü–∏–∏ –ø–ª–∞–Ω–∞
/// </summary>
internal class PlanAdaptationData
{
    [JsonPropertyName("adaptationStrategy")]
    public string AdaptationStrategy { get; set; } = "";
        
    [JsonPropertyName("reasoning")]
    public string Reasoning { get; set; } = "";
        
    [JsonPropertyName("newSubtasks")]
    public List<SubtaskData> NewSubtasks { get; set; } = new();
}